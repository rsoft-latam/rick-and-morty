{"ast":null,"code":"import { __assign, __decorate } from \"tslib\";\nimport { clamp } from './utils';\nimport { Options } from './options';\nimport { setStyle, clearEventsOn } from './utils/';\nimport { debounce } from './decorators/';\nimport { TrackController } from './track/';\nimport { getSize, update, isVisible } from './geometry/';\nimport { scrollTo, setPosition, scrollIntoView } from './scrolling/';\nimport { initPlugins } from './plugin';\nimport * as eventHandlers from './events/';\n// DO NOT use WeakMap here\n// .getAll() methods requires `scrollbarMap.values()`\nexport var scrollbarMap = new Map();\nvar Scrollbar = /** @class */function () {\n  function Scrollbar(containerEl, options) {\n    var _this = this;\n    /**\n     * Current scrolling offsets\n     */\n    this.offset = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Max-allowed scrolling offsets\n     */\n    this.limit = {\n      x: Infinity,\n      y: Infinity\n    };\n    /**\n     * Container bounding rect\n     */\n    this.bounding = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n    // private _observer: ResizeObserver;\n    this._plugins = [];\n    this._momentum = {\n      x: 0,\n      y: 0\n    };\n    this._listeners = new Set();\n    this.containerEl = containerEl;\n    var contentEl = this.contentEl = document.createElement('div');\n    this.options = new Options(options);\n    // mark as a scroll element\n    containerEl.setAttribute('data-scrollbar', 'true');\n    // make container focusable\n    containerEl.setAttribute('tabindex', '-1');\n    setStyle(containerEl, {\n      overflow: 'hidden',\n      outline: 'none'\n    });\n    // enable touch event capturing in IE, see:\n    // https://github.com/idiotWu/smooth-scrollbar/issues/39\n    if (window.navigator.msPointerEnabled) {\n      containerEl.style.msTouchAction = 'none';\n    }\n    // mount content\n    contentEl.className = 'scroll-content';\n    Array.from(containerEl.childNodes).forEach(function (node) {\n      contentEl.appendChild(node);\n    });\n    containerEl.appendChild(contentEl);\n    // attach track\n    this.track = new TrackController(this);\n    // initial measuring\n    this.size = this.getSize();\n    // init plugins\n    this._plugins = initPlugins(this, this.options.plugins);\n    // preserve scroll offset\n    var scrollLeft = containerEl.scrollLeft,\n      scrollTop = containerEl.scrollTop;\n    containerEl.scrollLeft = containerEl.scrollTop = 0;\n    this.setPosition(scrollLeft, scrollTop, {\n      withoutCallbacks: true\n    });\n    // FIXME: update typescript\n    var ResizeObserver = window.ResizeObserver;\n    // observe\n    if (typeof ResizeObserver === 'function') {\n      this._observer = new ResizeObserver(function () {\n        _this.update();\n      });\n      this._observer.observe(contentEl);\n    }\n    scrollbarMap.set(containerEl, this);\n    // wait for DOM ready\n    requestAnimationFrame(function () {\n      _this._init();\n    });\n  }\n  Object.defineProperty(Scrollbar.prototype, \"parent\", {\n    /**\n     * Parent scrollbar\n     */\n    get: function () {\n      var elem = this.containerEl.parentElement;\n      while (elem) {\n        var parentScrollbar = scrollbarMap.get(elem);\n        if (parentScrollbar) {\n          return parentScrollbar;\n        }\n        elem = elem.parentElement;\n      }\n      return null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"scrollTop\", {\n    /**\n     * Gets or sets `scrollbar.offset.y`\n     */\n    get: function () {\n      return this.offset.y;\n    },\n    set: function (y) {\n      this.setPosition(this.scrollLeft, y);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"scrollLeft\", {\n    /**\n     * Gets or sets `scrollbar.offset.x`\n     */\n    get: function () {\n      return this.offset.x;\n    },\n    set: function (x) {\n      this.setPosition(x, this.scrollTop);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the size of the scrollbar container element\n   * and the content wrapper element\n   */\n  Scrollbar.prototype.getSize = function () {\n    return getSize(this);\n  };\n  /**\n   * Forces scrollbar to update geometry infomation.\n   *\n   * By default, scrollbars are automatically updated with `100ms` debounce (or `MutationObserver` fires).\n   * You can call this method to force an update when you modified contents\n   */\n  Scrollbar.prototype.update = function () {\n    update(this);\n    this._plugins.forEach(function (plugin) {\n      plugin.onUpdate();\n    });\n  };\n  /**\n   * Checks if an element is visible in the current view area\n   */\n  Scrollbar.prototype.isVisible = function (elem) {\n    return isVisible(this, elem);\n  };\n  /**\n   * Sets the scrollbar to the given offset without easing\n   */\n  Scrollbar.prototype.setPosition = function (x, y, options) {\n    var _this = this;\n    if (x === void 0) {\n      x = this.offset.x;\n    }\n    if (y === void 0) {\n      y = this.offset.y;\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    var status = setPosition(this, x, y);\n    if (!status || options.withoutCallbacks) {\n      return;\n    }\n    this._listeners.forEach(function (fn) {\n      fn.call(_this, status);\n    });\n  };\n  /**\n   * Scrolls to given position with easing function\n   */\n  Scrollbar.prototype.scrollTo = function (x, y, duration, options) {\n    if (x === void 0) {\n      x = this.offset.x;\n    }\n    if (y === void 0) {\n      y = this.offset.y;\n    }\n    if (duration === void 0) {\n      duration = 0;\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    scrollTo(this, x, y, duration, options);\n  };\n  /**\n   * Scrolls the target element into visible area of scrollbar,\n   * likes the DOM method `element.scrollIntoView().\n   */\n  Scrollbar.prototype.scrollIntoView = function (elem, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    scrollIntoView(this, elem, options);\n  };\n  /**\n   * Adds scrolling listener\n   */\n  Scrollbar.prototype.addListener = function (fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('[smooth-scrollbar] scrolling listener should be a function');\n    }\n    this._listeners.add(fn);\n  };\n  /**\n   * Removes listener previously registered with `scrollbar.addListener()`\n   */\n  Scrollbar.prototype.removeListener = function (fn) {\n    this._listeners.delete(fn);\n  };\n  /**\n   * Adds momentum and applys delta transformers.\n   */\n  Scrollbar.prototype.addTransformableMomentum = function (x, y, fromEvent, callback) {\n    this._updateDebounced();\n    var finalDelta = this._plugins.reduce(function (delta, plugin) {\n      return plugin.transformDelta(delta, fromEvent) || delta;\n    }, {\n      x: x,\n      y: y\n    });\n    var willScroll = !this._shouldPropagateMomentum(finalDelta.x, finalDelta.y);\n    if (willScroll) {\n      this.addMomentum(finalDelta.x, finalDelta.y);\n    }\n    if (callback) {\n      callback.call(this, willScroll);\n    }\n  };\n  /**\n   * Increases scrollbar's momentum\n   */\n  Scrollbar.prototype.addMomentum = function (x, y) {\n    this.setMomentum(this._momentum.x + x, this._momentum.y + y);\n  };\n  /**\n   * Sets scrollbar's momentum to given value\n   */\n  Scrollbar.prototype.setMomentum = function (x, y) {\n    if (this.limit.x === 0) {\n      x = 0;\n    }\n    if (this.limit.y === 0) {\n      y = 0;\n    }\n    if (this.options.renderByPixels) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    this._momentum.x = x;\n    this._momentum.y = y;\n  };\n  /**\n   * Update options for specific plugin\n   *\n   * @param pluginName Name of the plugin\n   * @param [options] An object includes the properties that you want to update\n   */\n  Scrollbar.prototype.updatePluginOptions = function (pluginName, options) {\n    this._plugins.forEach(function (plugin) {\n      if (plugin.name === pluginName) {\n        Object.assign(plugin.options, options);\n      }\n    });\n  };\n  Scrollbar.prototype.destroy = function () {\n    var _a = this,\n      containerEl = _a.containerEl,\n      contentEl = _a.contentEl;\n    clearEventsOn(this);\n    this._listeners.clear();\n    this.setMomentum(0, 0);\n    cancelAnimationFrame(this._renderID);\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n    scrollbarMap.delete(this.containerEl);\n    // restore contents\n    var childNodes = Array.from(contentEl.childNodes);\n    while (containerEl.firstChild) {\n      containerEl.removeChild(containerEl.firstChild);\n    }\n    childNodes.forEach(function (el) {\n      containerEl.appendChild(el);\n    });\n    // reset scroll position\n    setStyle(containerEl, {\n      overflow: ''\n    });\n    containerEl.scrollTop = this.scrollTop;\n    containerEl.scrollLeft = this.scrollLeft;\n    // invoke plugin.onDestroy\n    this._plugins.forEach(function (plugin) {\n      plugin.onDestroy();\n    });\n    this._plugins.length = 0;\n  };\n  Scrollbar.prototype._init = function () {\n    var _this = this;\n    this.update();\n    // init evet handlers\n    Object.keys(eventHandlers).forEach(function (prop) {\n      eventHandlers[prop](_this);\n    });\n    // invoke `plugin.onInit`\n    this._plugins.forEach(function (plugin) {\n      plugin.onInit();\n    });\n    this._render();\n  };\n  Scrollbar.prototype._updateDebounced = function () {\n    this.update();\n  };\n  // check whether to propagate monmentum to parent scrollbar\n  // the following situations are considered as `true`:\n  //         1. continuous scrolling is enabled (automatically disabled when overscroll is enabled)\n  //         2. scrollbar reaches one side and is not about to scroll on the other direction\n  Scrollbar.prototype._shouldPropagateMomentum = function (deltaX, deltaY) {\n    if (deltaX === void 0) {\n      deltaX = 0;\n    }\n    if (deltaY === void 0) {\n      deltaY = 0;\n    }\n    var _a = this,\n      options = _a.options,\n      offset = _a.offset,\n      limit = _a.limit;\n    if (!options.continuousScrolling) return false;\n    // force an update when scrollbar is \"unscrollable\", see #106\n    if (limit.x === 0 && limit.y === 0) {\n      this._updateDebounced();\n    }\n    var destX = clamp(deltaX + offset.x, 0, limit.x);\n    var destY = clamp(deltaY + offset.y, 0, limit.y);\n    var res = true;\n    // offsets are not about to change\n    // `&=` operator is not allowed for boolean types\n    res = res && destX === offset.x;\n    res = res && destY === offset.y;\n    // current offsets are on the edge\n    res = res && (offset.x === limit.x || offset.x === 0 || offset.y === limit.y || offset.y === 0);\n    return res;\n  };\n  Scrollbar.prototype._render = function () {\n    var _momentum = this._momentum;\n    if (_momentum.x || _momentum.y) {\n      var nextX = this._nextTick('x');\n      var nextY = this._nextTick('y');\n      _momentum.x = nextX.momentum;\n      _momentum.y = nextY.momentum;\n      this.setPosition(nextX.position, nextY.position);\n    }\n    var remain = __assign({}, this._momentum);\n    this._plugins.forEach(function (plugin) {\n      plugin.onRender(remain);\n    });\n    this._renderID = requestAnimationFrame(this._render.bind(this));\n  };\n  Scrollbar.prototype._nextTick = function (direction) {\n    var _a = this,\n      options = _a.options,\n      offset = _a.offset,\n      _momentum = _a._momentum;\n    var current = offset[direction];\n    var remain = _momentum[direction];\n    if (Math.abs(remain) <= 0.1) {\n      return {\n        momentum: 0,\n        position: current + remain\n      };\n    }\n    var nextMomentum = remain * (1 - options.damping);\n    if (options.renderByPixels) {\n      nextMomentum |= 0;\n    }\n    return {\n      momentum: nextMomentum,\n      position: current + remain - nextMomentum\n    };\n  };\n  __decorate([debounce(100, true)], Scrollbar.prototype, \"_updateDebounced\", null);\n  return Scrollbar;\n}();\nexport { Scrollbar };\n//# sourceMappingURL=scrollbar.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}